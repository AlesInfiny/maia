---
title: 概要編
description: AlesInfiny Maia のアプリケーションアーキテクチャ概要を解説します。
---

# Java アプリケーションの処理方式 {#top}

アプリケーションの形態によらず、 Java アプリケーションで考慮すべき関心事について、実装方針を説明します。

## 例外処理方針 {#exception-policy}

アプリケーション全体での例外処理方針を定めます。

### 例外の種類 {#exception-pattern}

AlesInfiny Maia では、アプリケーションで発生する例外を[業務例外](#business-exception)と[システム例外](#system-exception)の 2 つに分類します。
それぞれの例外の意味や処理方針を以下に示します。

#### 業務例外 {#business-exception}

- 意味

    業務フロー上、想定されるエラーを表す例外です。

- 発生箇所

    アプリケーションコア層の業務ロジック内で、明示的にスローします。

- 処理方針

    プレゼンテーション層でキャッチし、業務フローに応じた処理を行います。

#### システム例外 {#system-exception}

- 意味

    業務フロー上は想定されないシステムのエラーを表す例外です。
    実行ランタイムまでキャッチされずに到達した例外は、すべてシステム例外として扱います。

- 発生箇所

    Java の実行ランタイム内からスローされます。
    またアプリケーションとして想定していない状態となったとき、業務ロジック内から明示的にスローすることがあります。

- 処理方針

    集約例外ハンドラー内でキャッチして、システムエラーの処理フローを実行します。

### 業務例外とシステム例外の使い分け {#usage-of-business-and-system-exceptions}

原則として、システム例外は業務ロジック内からスローしないようにします。
何らかのエラー状態を業務ロジックとして検出するのであれば、そのエラーを回復するための手段を業務フローとして設計し、業務例外として処理します。

ただし利用するライブラリによっては、本来システムエラーとして扱うべきエラーを、検査例外としてスローするケースがあります。
このようなケースでは、すべての検査例外に対応する業務ロジックを設計したり、ユーザーの再操作によってエラー状態を回復したりすることは困難です。
AlesInfiny Maia では、業務フロー内で検査例外が発生した際の処理として、システム例外に付け替えてリスローすることを許可します。

## ログ出力方針 {#logging-policy}

概要編では、一般的なログの種類とログレベルを定めます。
アプリケーション形態ごとに個別に検討が必要なものについては別途定めます。
アプリケーション形態別のアプリケーションアーキテクチャ解説も、あわせて参照してください。

### ログの種類 {#log-pattern}

AlesInfiny Maia で定義するログの種類は以下の通りです。

- 操作ログ

    ユーザーの操作履歴や、アプリケーションに対して行った操作を記録するログを操作ログと呼びます。

- 通信ログ

    アプリケーションがネットワークを介して通信する際、送受信する業務データや、送信先の情報、ヘッダー情報等を記録するログを通信ログと呼びます。

- 監査ログ

    アプリケーションの持つデータに対して行われた CRUD 処理を、誰がいつ実行したか記録するログを監査ログと呼びます。

- アプリケーションログ

    ここまでのログの種類に該当しない、アプリケーションのロジック内から出力する汎用的なログをアプリケーションログと呼びます。

### ログレベル {#log-level}

出力するログには、ログを出力する業務処理内で指定したログレベルを付与します。
ログに出力する情報によって、適切なログレベルを選択します。
ログレベルの定義は以下の通りです。

- FATAL

    業務の即時停止につながる可能性のあるログを出力するときに使用するログレベルです。

- ERROR

    一部の業務が停止する可能性のあるログを出力するときに使用するログレベルです。
    マスターデータの不整合や、原因の不明なエラー発生など、システム運用担当者による確認や対処が必要となる状態を通知する目的に使用します。

- WARN

    業務は継続できるものの、一時的に発生したエラー状態を出力するときに使用するログレベルです。
    業務エラーの記録など、システム運用担当者による対応は不要なものの、システムとして不安定な状態を記録する際使用します。

- INFO

    システム運用にあたって必要となる情報を出力するときに使用するログレベルです。
    バッチ処理の開始／終了の記録など、システムの状態を記録する際使用します。

- DEBUG

    開発者がアプリケーションの開発のために使用するログレベルです。
    各メソッドの入出力データなど、開発目的の情報を記録する際使用します。

### ログレベルと環境ごとの出力設定 {#configuration-of-log-levels-and-output-per-environment}

システムの実行環境にあわせて、適切なレベルのログを出力するように構成します。

| ログレベル |      本番環境      |     テスト環境     |  ローカル開発環境  |
| ---------- | :----------------: | :----------------: | :----------------: |
| FATAL      | :white_check_mark: | :white_check_mark: | :white_check_mark: |
| ERROR      | :white_check_mark: | :white_check_mark: | :white_check_mark: |
| WARN       | :white_check_mark: | :white_check_mark: | :white_check_mark: |
| INFO       | :white_check_mark: | :white_check_mark: | :white_check_mark: |
| DEBUG      |                    |                    | :white_check_mark: |

### ログに含める標準データ {#standard-log-data}

以下の情報をログに含めます。

- ログ出力日時
- ログレベル
- メッセージ
- スレッド名
- 例外メッセージとスタックトレース ( 例外を記録するログのみ )

!!! info "スレッド名の用途"
    スレッド名はログをトレースするために出力します。
    複数の処理が同時に動作しながらログ出力すると、各処理で出力したログが混ざりあった状態のログができあがります。
    スレッド名は、 1 つのスレッド内で出力したログだけをフィルタリングして、処理ごとにログを分解して解析するために使用できます。
    マルチスレッドプログラミングを行うなど、スレッド名だけではログのトレースが実現できない場合は、別途ログをトレースするための手段を検討します。

### ロギングライブラリ {#logging-libraries}

AlesInfiny Maia では、 Java アプリケーションのロギングライブラリとして [Apache Log4j 2](https://logging.apache.org/log4j/2.x/) を使用します。
またロギングファサードとして [SLF4J](https://www.slf4j.org/) を使用します。

## メッセージ管理方針 {#message-management-policy}

メッセージ文字列は、表記の統一を図る目的にプロパティファイルで管理します。

<!-- ### トランザクション管理 -->

## 入力検証方針 {#validation-policy}

入力値単体や、入力値同士の比較によって検証可能な入力値検証は、入出力インターフェースとなる場所で行います。
入力値単体では検証できず、データストア内のデータとの比較によって検証する場合はアプリケーションコア層の業務ロジックで検証します。

<!-- ### セキュリティ対策 -->

## ヘルスチェックの必要性 {#health-check-necessity}

AlesInfiny Maia では、受信端末とサーバー間の通信が正常に行えるかを確認する「ヘルスチェック」について定めています。

### 目的・背景 {#health-check-background}

ヘルスチェックの目的は、ロードバランサー（以下、 LB と記載する）がサーバーの稼働状況を監視することです。
ヘルスチェックによりサーバーの稼働状況を監視することで、以下のようなメリットが期待できます。

- 負荷分散

    大量のユーザーからのアクセスを複数のサーバーに割り振ることで負荷分散を行います。
    これによりレスポンスの低下を防止しサービスを継続的かつ効率的に運用できます。

- サーバー故障への対応

    ヘルスチェック機能でサーバーの稼働状況を監視することで、サーバーの異常の検知が可能です。
    サーバーの異常を検知した際には正常なサーバーに自動的に動作を引き継ぐことで、 Web システムの運用停止を防止できます。

このように、 LB による監視を行い負荷の分散や運用停止を防止するために、ヘルスチェック機能を実装する必要があります。

### 基本方針 {#health-check-policy}

LB が行うヘルスチェックには、使用するプロトコルレイヤーの違いによって、以下に示すような種類で分類できます。

| プロトコルレイヤー  |                                                         詳細                                                                |
| ---------------  | -------------------------------------------------------------------------------------------------------------------------   |
| Layer 3          | OSI 参照モデルのネットワーク層で動作を監視します。 ICMP echo リクエストを送信し、 echo リプライが帰ってくるかどうかを確認します。    |
| Layer 4          | OSI 参照モデルのトランスポート層で動作を監視します。 TCP のハンドシェイクを行い、サーバーの動作を確認します。                       |
| Layer 7          | OSI 参照モデルのアプリケーション層で動作を監視します。 HTTP リクエストから、サーバーの HTTP レスポンスの確認により動作を確認します。  |

ここで、 Layer 3 や Layer 4 のプロトコルレイヤーで行うヘルスチェックは、作成した Web アプリケーションの稼働状況まで確認できません。
AlesInfiny Maia のように Web アプリケーションが正常に動作しているかどうかまでを対象としてヘルスチェックを行う場合は、 Layer 7 のプロトコルによる監視が必要となります。
そのため、本ドキュメントは Layer 7 のプロトコルでのヘルスチェックを行うことを推奨します。

### レスポンス形式 {#health-check-response}

ヘルスチェックを確認する HTTP レスポンスとして、サーバーの正常値と異常値を表すステータスコードとレスポンスボディを定義する必要があります。
そこで、本ドキュメントでは以下のように定義しています。

- ステータスコード

    Azure や AWS といったクラウドサービスにおける HTTP レスポンスのステータスコードには、主に 200 を正常値、 4xx ～ 5xx を異常値としています。
    また、ヘルスチェックでは詳細に異常値の内容を表現することよりも機械的に処理しやすいようシンプルな形に固定することが重要です。
    そのため、本ドキュメントでは正常値を 200 、異常値を 503 で統一します。

- レスポンスボディ

    レスポンスボディの内容は、頻繁に状態監視することによる通信量の増加に対応するため、簡潔な形に固定する必要があります。
    そのため、サーバーの動作状態を表す内容のみをレスポンスボディとすることが重要です。
