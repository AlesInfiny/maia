---
title: CSR 編
description: クライアントサイドレンダリングを行う Web アプリケーションのアーキテクチャについて解説します。
---

# 全体処理方式 {#top}

クライアントサイドレンダリング方式のアプリケーション全体で考慮すべきアーキテクチャについて、その実装方針を説明します。

## 例外処理方針 {#exception-policy}

バックエンドアプリケーションで発生するシステム例外や業務例外は、例外フィルターによって捕捉します。
例外フィルターでは、ログ出力方針に従ってアプリケーションログを出力します。

システム例外を例外フィルターで捕捉した場合は、 HTTP 500 のエラーレスポンスをフロントエンドアプリケーションに返却します。
フロントエンドアプリケーションは、システムエラー画面に遷移し、 Sorry メッセージを出力します。
フロントエンドアプリケーション内で例外が発生した場合も、同様にシステムエラー画面に遷移します。

業務例外を例外フィルターで補足した場合は、 HTTP 400 のエラーレスポンスをフロントエンドアプリケーションに返却します。
フロントエンドアプリケーションは、その画面内のメッセージ領域にエラーメッセージを表示します。

![例外処理方針](../../images/app-architecture/client-side-rendering/exception-handling-policy-light.png#only-light){ loading=lazy }
![例外処理方針](../../images/app-architecture/client-side-rendering/exception-handling-policy-dark.png#only-dark){ loading=lazy }

## ログ出力方針 {#logging-policy}

Java アプリケーションのログ出力方針については、以下を参照してください。

- [Java アプリケーションの処理方式 - ログ出力方針](../../app-architecture/overview/java-application-processing-system.md#logging-policy)

以降、本節では Vue.js のフロントエンドアプリケーションのログ出力方針を示します。

### ログの種類 {#log-pattern}

AlesInfiny Maia で定義するフロントエンドアプリケーションのログの種類は以下の通りです。

- アプリケーションログ

    アプリケーションのロジック内から出力する汎用的なログをアプリケーションログと呼びます。
    フロントエンドアプリケーションから出力するログは、主に開発目的で出力します。

### ログレベル {#log-level}

出力するログにはログレベルを定義します。
フロントエンドアプリケーションのログレベルの定義は以下の通りです。

- Error

    システムエラー発生時に使用します。

- Warning

    業務エラー発生時に使用します。

- Information ( ログレベル指定なし )

    開発者のデバッグ目的に使用してもかまいませんが、原則使用しません。

### ログレベルと環境ごとの出力設定 {#configuration-of-log-levels-and-output-per-environment}

フロントエンドアプリケーションは、システムの実行環境によらず、すべてのレベルのログを出力します。

### ログに含める標準データ {#standard-log-data}

以下の情報をフロントエンドアプリケーションのログに含めます。

- ログ出力日時
- ログレベル
- メッセージ

### ロギングライブラリ {#logging-libraries}

フロントエンドアプリケーションでは `#!ts console` オブジェクトを利用して、ログをブラウザーのデバッグコンソールに出力します。

## メッセージ管理方針 {#message-management-policy}

Java アプリケーションのメッセージ管理方針については、以下を参照してください。

- [Java アプリケーションの処理方式 - メッセージ管理方針](../../app-architecture/overview/java-application-processing-system.md#message-management-policy)

フロントエンドアプリケーションでは、特別なメッセージ管理しません。
画面内に出力するメッセージやラベルは、各画面やソースコード内に個別に実装したものを使用します。

<!-- ### トランザクション管理 -->

## 入力値検査方針 {#validation-policy}

入力値検査は単項目チェックと項目間チェック、複合チェックに分類し、それぞれ以下の方針で処理します。

### 単項目チェック {#single-item-check}

入力必須チェック、桁チェック、型チェックなど、単一の項目のみで完結する入力値検証です。
フロントエンドアプリケーションとバックエンドアプリケーション、それぞれで同一の入力値検証します。

フロントエンドアプリケーションでは、入力誤りの情報を素早くユーザーにフィードバックすることを目的に実行します。
バックエンドアプリケーションで行う入力値検証を補助します。
入力値検証は VeeValidate と yup を利用して行います。

バックエンドアプリケーションでは、誤った入力情報がシステムに投入されることを防止する目的に行います。
入力値検証は Bean Validation を利用して行います。

### 項目間チェック {#cross-field-check}

パスワードと確認用パスワードの一致チェック、タスク終了日が開始日より後であることのチェックなど、複数の項目を比較する入力値検証です。
フロントエンドアプリケーションとバックエンドアプリケーションで、同一の項目を持つ場合は、それぞれで同一の入力値検証します。

フロントエンドアプリケーションでは、入力誤りの情報を素早くユーザーにフィードバックすることを目的に実行します。
バックエンドアプリケーションで行う入力値検証を補助します。
入力値検証は VeeValidate と yup を利用して行います。

バックエンドアプリケーションでは、誤った入力情報がシステムに投入されることを防止する目的に行います。
入力値検証はプレゼンテーション層の業務ロジック内で実装します。
繰り返し使用するものは Bean Validation を独自拡張して汎用化します。

### 複合チェック {#complex-check}

ID の重複チェック、注文数が在庫数以内であるかのチェックなど、システムの状態によって入力値が妥当かどうかが変わる入力値検証です。
多くの場合、データストア内のデータと突き合わせて乳領地の妥当性を確認します。

複合チェックはバックエンドアプリケーションでのみ行います。
アプリケーションコア層の業務ロジック内でチェック処理を実装します。
入力エラーがある場合は、 HTTP 400 のステータスコードを使用して、エラーの存在を通知します。
また入力エラーのあった個所とエラーメッセージを、エラーレスポンスの本文を使用して通知します。

<!-- ### セキュリティ対策 -->

## ヘルスチェック機能の実装 {#health-check-implementation}

AlesInfiny Maia において定義しているヘルスチェックの実装例について説明します。

ヘルスチェック機能の概要については、[ヘルスチェックの必要性](../overview/java-application-processing-system.md#health-check-necessity)を参照してください。

### ヘルスチェック機能の 2 種類のプローブ {#health-check-probe}

ヘルスチェック機能を実装する際、以下に示すいずれかの要素を確認することで正常に動作しているとみなすことができます。

- 活動性

    アプリがクラッシュしていたり、再起動の必要性が発生したりしていないこと。

- 対応性

    アプリが正常に動作していて、かつリクエストを受信する準備ができていること。

これら 2 つの要素を満たすため、 AlesInfiny Maia のサンプルアプリケーションでは活動性と対応性の状態をユーザーに渡す 2 種類のプローブを定義します。
詳細については[実装方針](#implementation-policy)に示します。

### 実装方針 {#implementation-policy}

Spring Boot を用いた Web アプリケーションにおいて、アプリケーションレベルでサーバーの監視、管理する追加機能である[Spring Boot Actuator](https://spring.pleiades.io/spring-boot/docs/current/reference/html/actuator.html) モジュールを適用できます。

Spring Boot Actuator モジュールの中にはヘルスチェック機能が含まれています。
プレゼンテーション層の application.properties で Spring Boot Actuator の環境設定によって、比較的容易にヘルスチェックの機能を実現できます。
 AlesInfiny Maia における設定内容の詳細に関しては、サンプルアプリケーションを参照してください。

AlesInfiny Maia のサンプルアプリケーションでは、[前節](#health-check-probe)で述べた通り活動性と対応性をそれぞれ満たす 2 つのプローブを実装しており、
以下のアドレスでヘルスチェックの状態を確認できます。

- 活動性のプローブ（<http://localhost:8080/api/health/check>）

    アプリが正常に動作していることを確認するためのプローブ。

- 対応性のプローブ（<http://localhost:8080/api/health/datasource>）

    データベースの正常動作によって、リクエストを受信する準備ができていることを確認するためのプローブ。

本ドキュメントにおける[ヘルスチェックのレスポンス形式](../overview/java-application-processing-system.md#health-check-response)に基づき、アクセスしたアドレスからの HTTP レスポンスは以下のように定義します。これにより、簡潔な形でサーバーの状態を把握できます。

| ステータス      | ステータスコード | レスポンスボディ                | 詳細                                       |
| -------------- | --------------- | ----------------------------- | ------------------------------------------ |
| UP             | 200             | { "status": "UP"}             | サーバーが正常に起動している                  |
| DOWN           | 503             | { "status": "DOWN"}           | サーバーが異常を起こし停止している            |
| OUT_OF_SERVICE | 503             | { "status": "OUT_OF_SERVICE"} | サーバーが意図的にシャットダウンしている       |
| UNKNOWN        | 200             | { "status": "UNKNOWN"}        | サーバーが定義していないステータスである       |
